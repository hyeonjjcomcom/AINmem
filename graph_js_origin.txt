let currentFilter = 'all';
let nodes = new Map();
let links = [];
let simulation;
let showLabels = true;

const svg = d3.select("#graph");
const container = document.querySelector('.graph-container');
const width = Math.max(svg.node().getBoundingClientRect().width, 800);
const height = 600;

const color = d3.scaleOrdinal()
    .domain(['wan_ai', 'artany', 'business'])
    .range(['#ff6b6b', '#4ecdc4', '#45b7d1']);

function filterData() {
    if (currentFilter === 'all') return data;
    return data.filter(item => item.category === currentFilter);
}

function buildGraph() {
    const filteredData = filterData();
    nodes.clear();
    links.length = 0;

    // constant의 등장 횟수와 카테고리 추적
    const constantCount = new Map();
    const constantCategories = new Map();

    // 먼저 모든 constants를 수집하고 등장 횟수 계산
    filteredData.forEach(item => {
        item.constants.forEach(constant => {
            if (constant !== 'x' && constant !== 'y' && constant !== 'u' && constant !== 'm' && constant !== 's') {
                constantCount.set(constant, (constantCount.get(constant) || 0) + 1);
                // 카테고리 정보도 저장 (처음 등장하는 카테고리 사용)
                if (!constantCategories.has(constant)) {
                    constantCategories.set(constant, item.category);
                }
            }
        });
    });

    // constant 노드 생성
    constantCount.forEach((count, constant) => {
        nodes.set(constant, {
            id: constant,
            name: constant,
            type: 'constant',
            count: count,
            category: constantCategories.get(constant),
            group: 1
        });
    });

    // 링크 생성 (constants 간의 연결)
    filteredData.forEach(item => {
        const validConstants = item.constants.filter(c => 
            c !== 'x' && c !== 'y' && c !== 'u' && c !== 'm' && c !== 's'
        );
        
        // 단일 술어의 경우 (예: has_GoodVideoGenerationAbility(wan_ai_2.2))
        if (item.predicates.length === 1 && validConstants.length === 1) {
            // 자기 자신으로의 링크는 생성하지 않음
            return;
        }
        
        // 이항 술어의 경우 (예: DevelopedBy(Alibaba, wan_ai_2.2))
        if (validConstants.length === 2) {
            links.push({
                source: validConstants[0],
                target: validConstants[1],
                predicate: item.predicates[0],
                description: item.description,
                category: item.category
            });
        }
        
        // 다중 술어의 경우 첫 번째 상수를 중심으로 연결
        if (item.predicates.length > 1 && validConstants.length === 1) {
            // 이 경우는 is_VideoAI(wan_ai_2.2) ∧ is_OpenSource(wan_ai_2.2) 같은 경우
            // 특별한 처리가 필요하다면 여기서 구현
        }
    });

    // 통계 업데이트
    document.getElementById('node-count').textContent = nodes.size;
    document.getElementById('link-count').textContent = links.length;
}

function createGraph() {
    buildGraph();
    svg.selectAll("*").remove();

    // 노드 크기 스케일 (등장 횟수에 따라)
    const maxCount = Math.max(...Array.from(nodes.values()).map(n => n.count));
    const radiusScale = d3.scaleLinear()
        .domain([1, maxCount])
        .range([15, 30]);

    simulation = d3.forceSimulation(Array.from(nodes.values()))
        .force("link", d3.forceLink(links).id(d => d.id).distance(150))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(d => radiusScale(d.count) + 10));

    // 링크 그리기
    const link = svg.append("g")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "link");

    // 링크 라벨 (predicate 이름)
    const linkLabel = svg.append("g")
        .selectAll("text")
        .data(links)
        .enter().append("text")
        .attr("class", "link-label")
        .text(d => d.predicate)
        .style("opacity", showLabels ? 1 : 0);

    // 노드 그리기
    const node = svg.append("g")
        .selectAll("g")
        .data(Array.from(nodes.values()))
        .enter().append("g")
        .attr("class", "node")
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

    node.append("circle")
        .attr("r", d => radiusScale(d.count))
        .attr("fill", d => color(d.category))
        .attr("title", d => `${d.name} (등장 횟수: ${d.count})`);

    const nodeText = node.append("text")
        .text(d => d.name)
        .style("opacity", showLabels ? 1 : 0);

    simulation.on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        linkLabel
            .attr("x", d => (d.source.x + d.target.x) / 2)
            .attr("y", d => (d.source.y + d.target.y) / 2);

        node
            .attr("transform", d => `translate(${d.x},${d.y})`);
    });

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    window.currentNodeText = nodeText;
    window.currentLinkLabel = linkLabel;
}

function restart() {
    createGraph();
}

function toggleLabels() {
    showLabels = !showLabels;
    if (window.currentNodeText) {
        window.currentNodeText.style("opacity", showLabels ? 1 : 0);
    }
    if (window.currentLinkLabel) {
        window.currentLinkLabel.style("opacity", showLabels ? 1 : 0);
    }
}

function centerGraph() {
    if (simulation) {
        simulation.alpha(0.3).restart();
    }
}

// 필터 이벤트 리스너
document.querySelectorAll('.filter-tag').forEach(tag => {
    tag.addEventListener('click', function() {
        document.querySelectorAll('.filter-tag').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        currentFilter = this.dataset.filter;
        createGraph();
    });
});

// 초기 그래프 생성
createGraph();

// 윈도우 리사이즈 시 그래프 업데이트
window.addEventListener('resize', () => {
    const newWidth = Math.max(svg.node().getBoundingClientRect().width, 800);
    if (simulation) {
        simulation.force("center", d3.forceCenter(newWidth / 2, height / 2));
        simulation.alpha(0.3).restart();
    }
});